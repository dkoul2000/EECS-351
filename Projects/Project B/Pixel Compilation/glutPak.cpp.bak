//3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_
/* (JT: I prefer to keep line lengths <=80 chars for easy printing/display).

	glutPak.cpp

    Demo of GLUT API for operating system services and GUI callbacks.

2010.12.13-J. Tumblin: created for use in EECS351-1 at Northwestern University
2011.09.08-J. Tumblin: added openGL bitmap examples and image-file reading
*=============================================================================*/

#include "glutPak.h"

//=====================
// GLOBAL VARIABLE(S): bad idea, but forced by GLUT's fixed-arg callback fcns.
//                   Always use as FEW global vars as possible.  Best strategy
//                   is usually to create a top-level class that holds all
//                   data and functions for your program.  Then make just one
//                   object of this class, and let that be the one and only
//                   global variable.  This 'top-level' class is a good idea
//                   for ANY object-oriented program, as it lets you make
//                   multiple instances of your entire app just by making more
//                   objects of that top-level class.
//=====================
CTheApp myApp;              // Our one-and-only top-level object.  It holds all
                            // the app's state variables that would otherwise
                            // have to be declared as global.

#ifndef M_PI                // be sure pi exists
#define M_PI acos(-1.0)     // ugly, slow, but accurate replacement for M_PI
#endif

int main(int argc, char *argv[])
//=============================================================================
{
    //--Setup for GLUT----------------------
    // BETTER IDEA: create your own member function of CTheApp class to hold
    // all this mess (perhaps 'myApp.glutSetup(argc, argv)' ? Make your own! )
	glutInit( &argc, argv );	    // init GLUT user-interface library;
	glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_STENCIL);
                    // Set up all display-frame-buffers we may use;
					// single-buffering GLUT_SINGLE, or
					// double-buffering GLUT_DOUBLE, where you'd need to call
					// glutSwapBuffers() after drawing operations to show
					// on-screen what you draw)
                    // full 32-bit/pixel RGBA (not RGB)color,(A =alpha=opacity),
					// enable depth testing for 3D drawing ('Z-buffering')
					// enable 'stencil' buffer (useful for masks, shadows, etc)
	glutInitWindowSize(myApp.display_width, myApp.display_height );
    glutInitWindowPosition(myApp.display_xpos, myApp.display_ypos );
                    // set display window size & position (from global vars)
	glutCreateWindow(myApp.winTitle); // set window title-bar name
	glClearColor(myApp.clrColr4dv[0],
                 myApp.clrColr4dv[1],
                 myApp.clrColr4dv[2],
                 myApp.clrColr4dv[3]);// set openGL's 'cleared-screen' color
    glEnable(GL_DEPTH_TEST);        // Enable z-depth tests for all drawing.
                                    // (SURPRISE! default setting is 'disable')
	// Register all the GLUT callback functions this program uses:
	glutDisplayFunc( myDisplay );	// callback for display window redraw
	glutReshapeFunc( myReshape);    // callback to create or re-size window
	glutKeyboardFunc( myKeyboard);  // callback for alpha-numeric keystroke
	glutSpecialFunc ( myKeySpecial);// callback for all others: arrow keys,etc.
	glutMouseFunc( myMouseClik );   // callback for mouse button events
	glutMotionFunc( myMouseMove );  // callback for mouse dragging events
	glutVisibilityFunc(myHidden);   // callback for display window cover/uncover
	//-----------------------------------
    runAnim(1);                     // start our animation loop.
	glutMainLoop();	                // enter GLUT's event-handler; NEVER EXITS.
	return 0;                       // normal exit.
}

void myReshape( int dispWidth, int dispHeight )
//------------------------------------------------------------------------------
// Called by GLUT whenever you re-size the display window(e.g. drag its corners)
// ALSO called on initial creation of the window.  Use defaults or the width,
// height arguments given in glutInitWindowSize(); (see main() fcn.).
{
    myApp.display_width    = dispWidth;    // save the current display size
    myApp.display_height   = dispHeight;   // reported as callback arguments.

//==================ON_SCREEN_COORDINATES================
// Modern openGL programs use floating-point values to set (x,y,z) positions of
// all drawing primitives (points, lines, shapes, etc) that appear on-screen.
//
//  At first, this question is surprisingly tricky:
//      ****"What coordinates, what NUMBERS, will put something on-screen?"***
//
// SHORT ANSWER:
// ----------------
//  --By default, OpenGL fills the display screen with (x,y,z) values between
//      +1.0 and -1.0.  To see what you draw, keep x,y,z values between +/-1.0.
//      (HINT: Don't register the 'reshape' callback fcn!)
//
//  --This 3D cube-shaped range of xyz values, this 'Canonical View Volume'(CVV)
//      is fixed; no function or command can change it.  However,
//
//  --The glViewport() function modifies how the CVV fits into the on-screen
//      display window.  When the window shape changes, (and GLUT calls the
//      'reshape()' callback function), many programs change their 'viewport'.
//
// DETAILED ANSWER:
//-------------------
// OpenGL version 2.1 and earlier transforms all drawing primitives (vertices)
// twice before they make a picture in 'the CVV', then once more by the
// 'viewport' to fit the contents of the CVV to the screen.  Before display,
// openGL transforms ALL vertex locations (x,y,z):
//  --first by the GL_MODELVIEW matrix used to:
//          -- build and place3D jointed shapes (the 'MODEL' part), and to
//          -- position and aim your camera (the 'VIEW' part).
//  --second by the GL_PROJECTION matrix used to:
//          --define the 3D-to-2D 'camera' that makes a picture.  It creates a
//          perspective image (2D + z-pseudo-depth) from the 3D vertices sent
//          to it from the GL_MODELVIEW matrix.
//  Then openGL hardware then 'clips' these picture values to the CVV.
//          --it discards any part of any drawing primitive that leaves the
//          GL_PROJECTION matrix  with x,y,z values outside the range +/-1.
//          --This cube-shaped range (+/-1.0 ,+/-1.0 ,+/-1.0), is the
//          'Canonical View Volume' (CVV). Any part of any drawing primitive
//          outside the CVV cannot appear on-screen.
//          The CVV is fixed: no command can change it, ever!
//  --Finally, the 'viewport' matrix (set by the glViewport() command) maps the
//  CVV's contents to a selected portion (or all) of the display window.
//--------------------!
//  CAREFUL! *ALL THREE* matrices can change the position of any vertex within
// the display window, and users may change the display window size & location.
//--------------------!
//   So, what goes where?  What vertex coordinates actually arrive on-screen?
//                   ANSWER: all parts of all transformed primitives that
//                   fall within the portion of the CVV shown on the display.
// Fortunately, openGL sets sensible initial values for everything.
// Initially, GL_MODELVIEW and GL_PROJECTION both hold 4x4 indentity matrices
// that leave vertex values unchanged.  Initially, the Viewport matrix holds
// values that (thanks to GLUT) fill your display window with the entire CVV.
// With those initial settings, all vertices that specify (x,y,z) values
// within (+/-1, +/-1, +/-1) (inside the CVV) can create on-screen pictures.
// If you mess up the matrices, you can always return to this initial state by
// re-initializing all the 3 matrices:
//          glMatrixMode(GL_MODELVIEW); // select and
//          glLoadIdentity();           // set to identity matrix.
//          glMatrixMode(GL_PROJECTION);// select and
//          glLoadIdentity();           // set to identity matrix.
//          glViewport(0,0,screenWidth,screenHeight); // fill screen with CVV.
//
// HOW TO SET THE VIEWPORT--------------
// The glViewport() command specifies where to show the CVV contents within the
// on-screen display window.   The method is rather odd, neglected and official
// explanations are complicated, so I suggest you remember the glViewport()
// arguments as:
//
//          glViewport(GLint xLL, GLint yLL, GLint CVVwidth, GLint CVVheight);
//
// --The (xLL,yLL) arguments specify the display window's pixel address for the
//   CVV's (-1,-1) (lower-left) corner; any vertex that leaves the GL_PROJECTION
//   matrix with value(-1,-1, -1.0<= z <1.0) will appear at (xLL,yLL) in your
//   program's display window pixel coords (whose origin is at the lower left).
// --The 'CVVwidth' and 'CVVheight' specify how many pixels the entire CVV would
//   cover on-screen if the display window is large enough to hold it.  If the
//   display window is larger, some window regions will remain empty. If too
//   small, the display window will show only the portion of the CVV that fits
//   inside the window.
//
// The CVV is always square (+/-1), but our display windows are not.  The
// contents of the always-square CVV may not look their best if squashed or
// stretched to fill an entire non-square display window. Remember, you're not
// required to fill every pixel of the display window with openGL drawings,
// and/or you don't have to show the entire CVV within your display window.
// The best-looking results keep CVVwidth = CVVheight in calls to glViewport().
// To start, try one of these: (comment out all but one):
//------------------------------
  glViewport(0,0,dispWidth, dispHeight); // fill the whole window with CVV.
                            // (will squash/stretch CVV contents on-screen!)
//-------------------------------
//  glViewport(0,0, dispWidth, dispWidth);// viewport may extend past window TOP
//-------------------------------
//  glViewport(0,0,dispHeight,dispHeight);// viewport may extent past window RIGHT
//-------------------------------
/*
    // Draw CVV in the display window's largest centered, inscribed square:
    if(dispWidth > dispHeight)
    {	// WIDE window:  height sets viewport size, and
        glViewport((dispWidth-dispHeight)/2, 0, dispHeight, dispHeight);
    	// move origin rightwards to keep image centered horizontally in window.
    }   // CVV depiction stays SQUARE and centered;empty regions on left, right.
    else
    {	// TALL window:  width sets viewport size, and
        glViewport(0,(dispHeight-dispWidth)/2, dispWidth, dispWidth);
        // need to origin upwards to keep image centered vertically in window
    }	// CVV depiction stays SQUARE and centered; empty regions above & below.
*/
//--------------------------------
// or invent your own;
// ++Perhaps fit the window INSIDE a square CVV depiction?
// ++Could you draw TWO viewports on-screen, side-by-side in the same window,
// and draw a different picture in each of them? FOUR viewports? SIX? etc.

// BEST SOLUTION:-----------------
// ++Fill the (non-square) display window with the entire CVV, but then
//      eliminate the squash/stretch by constructing a camera in GL_PROJECTION
//      with a non-square field of view--a field of view whose aspect ratio
//      (width/height) MATCHES the display window.  (Highly recommended method,
//      because it draws undistorted images in the entire display window, and
//      the CVV clips drawing primitives only at the display window limits)
//   --Use glViewport(0,0,dispWidth, dispHeight); to fill the display with CVV,
//      then use openGL's glFrustum() or gluPerspective() to set the camera.
//
	glutPostRedisplay();			// request redraw--we changed window size!
}

void myDisplay( void )
//------------------------------------------------------------------------------
// (REGISTERED AS GLUT 'display' CALLBACK--don't call this fcn in your code!)
// GLUT calls this fcn. whenever it needs to re-draw the display window.
// OPENGL TRANSFORMATION SYNTAX HINTS:
//	glRotated(-123, 1,-2,1);	// rotate by -123 degrees around 3D axis(1,-2,1)
//	glScaled(0.2, 0.3, 0.4);	// shrink along x,y,z axes;
//  glTranslated(0.1, 0.3, 0.5);// translate along x,y,z axes.
{
    if(myApp.doClear==1)
    {   // toggled by 'c' or 'C' key, ==1 shows shapes, ==0 shows time-trails.
        glClear( GL_COLOR_BUFFER_BIT |      // clear the color image buffer,
                 GL_DEPTH_BUFFER_BIT |      // clear the depth ('z') buffer,
                 GL_STENCIL_BUFFER_BIT );   // clear the stencil mask, if any.
    }
    //------------------------------ANIMATION:
    myApp.shape_deg += myApp.shape_degStep;  // Move forwards by one step.
    // angular wraparound; keep angles between +/-180 degrees.
    if(myApp.shape_deg > 180.0) myApp.shape_deg -= 360.0;
    if(myApp.shape_deg <-180.0) myApp.shape_deg += 360.0;
    //----------------------------------------

    myApp.drawAxes();               // Draw current coordinate axes to show
                                    // origin at window center. (r,g,b==x,y,z)
    myApp.drawShape();              // Draw our selected shape.
                                    // (try function keys to change shapes).
    myApp.drawText3d(-0.9, -0.60, -0.9,
                     "Arrow keys, PgUp/PgDn, Home key to move object in x,y,z;", 1);
    myApp.drawText3d(-0.9, -0.65, -0.9,
                     "F1--change object; F2/F3 change spin rate;", 1);
    myApp.drawText3d(-0.9, -0.70, -0.9,
                     "Try mouse; Try A,C,P, and other keys", 1);
    myApp.drawText3d(-0.9, -0.75, -0.9,
                     "Hit 'f' or 'F' key for filename prompt.", 1);
    myApp.drawText3d(-0.9, -0.80, -0.9,
                     "To quit, hit Q, q, ESC or SPACE bar.", 1);

// OpenGL bitmap drawing tests:
myApp.drawBitmapTest();
myApp.drawPixBlockTest();
myApp.readPixBlockTest();
myApp.copyPixBlockTest();

	//===============DRAWING DONE.
	glFlush();	                // do any and all pending openGL rendering.
//	cout << "*";                // tick-mark for each sensed position change
	glutSwapBuffers();			// For double-buffering: show what we drew.
}

void myKeyboard(unsigned char key, int xw, int yw)
//------------------------------------------------------------------------------
// (REGISTERED AS GLUT 'keyboard' CALLBACK--don't call this fcn in your code!)
// GLUT calls this fcn when users press an alphanumeric key on the keyboard.
//	xw,yw == mouse position in window-system pixels (origin at UPPER left)
//  (NOTE!  freeGLUT also provides glutKeyboardUpFunc() to register a callback
//      called when users RELEASE keyboard key.
//      SEE: http://freeglut.sourceforge.net/docs/api.php#Introduction
{
int xpos,ypos;  // mouse position in coords with origin at lower left.

    xpos = xw;
    ypos = myApp.display_height - yw;//(window system puts origin at UPPER left)
    myApp.reportKeyModifiers("myKeyboard()"); //Report any SHIFT,ALT,CTRL usage
	switch(key)
	{
		case 'A':       // User pressed the 'A' key...
		case 'a':
		cout << "that *IS* the 'A' key!\n";
			break;
        case 'c':
        case 'C':       // toggle 'isCleared' to enable/disable screen clearing
                        // in myDisplay before screen redrawing.
            cout <<"C key toggles screen-clearing on/off" << endl;
            if(myApp.doClear==0) myApp.doClear = 1;
                            else myApp.doClear = 0;
            break;
        case 'f':
        case 'F':       // Prompt for filename
            cout << "F key calls printPixelStoreTest(), and in file 'test.ppm' :" << endl;
            myApp.printPixelStoreTest();
//            myApp.myImg.readFilePPM("test.ppm");
            break;
        case 'p':
        case 'P':       // Toggle animation on/off.
            cout << "P key toggles animation on/off" << endl;
            if(myApp.doAnim ==1) runAnim(0);
                            else runAnim(1);
            break;
		case ' ':		// User pressed the spacebar.
		case 27:		// User pressed the 'Esc'  key...
		case 'Q':		// User pressed the 'Q' key...
		case 'q':
			exit(0);    // Done! quit the program.
			break;
        default:
            cout << "Keyboard: you pressed the '" << key << "' key."<<endl;
	        myApp.drawText3d(0.0, 0.80, -0.9, "!!WHAT??", 4);
            myApp.drawText3d(0.0, 0.72, -0.9, "!!WHAT??", 4);
            myApp.drawText3d(0.0, 0.64, -0.9, "!!WHAT??", 4);
            //===============DRAWING DONE.
            glFlush();	        // do any and all pending openGL rendering.
            glutSwapBuffers();	// For double-buffering: show what we drew.
        break;
	}
}

void myKeySpecial(int key, int xw, int yw)
//------------------------------------------------------------------------------
// (REGISTERED AS GLUT 'keySpecial' CALLBACK--don't call this fcn in your code!)
// Called by GLUT when users press 'arrow' keys, 'Fcn' keys, or any other
// non-alphanumeric key.  A quick summary:
//    GLUT_KEY_F1, GLUT_KEY_F2, ..., GLUT_KEY_F12 - F1 through F12 keys
//    GLUT_KEY_PAGE_UP, GLUT_KEY_PAGE_DOWN - Page Up and Page Down keys
//    GLUT_KEY_HOME, GLUT_KEY_END - Home and End keys
//    GLUT_KEY_LEFT, GLUT_KEY_RIGHT, GLUT_KEY_UP, GLUT_KEY_DOWN - Arrow keys
//    GLUT_KEY_INSERT - Insert key
// Search glut.h to find other #define literals for
// special keys, such as GLUT_KEY_F1, GLUT_KEY_UP, etc.
//	xw,yw == mouse position in window-system pixels (origin at UPPER left!)
//
//  (NOTE!  freeGLUT also provides glutSpecialUpFunc() to register a callback
//      called when users RELEASE 'special' key on the keyboard)
//      SEE: http://freeglut.sourceforge.net/docs/api.php#Introduction
{
int xpos,ypos;      // mouse position in coords with origin at lower left.

    xpos = xw;
    ypos = myApp.display_height - yw;//(window system puts origin at UPPER left)
    myApp.reportKeyModifiers("myKeySpecial()");//Report any SHIFT,ALT,CTRL usage
	switch(key)
	{
		case GLUT_KEY_LEFT:		// left arrow key
            myApp.shape_xpos -= 0.025;
            cout << "left-arrow key. \t myApp.shape_xpos = "
                 << myApp.shape_xpos << endl;
			break;
		case GLUT_KEY_RIGHT:	// right arrow key
            myApp.shape_xpos += 0.025;
            cout << "right-arrow key. \t myApp.shape_xpos = "
                 << myApp.shape_xpos << endl;
			break;
		case GLUT_KEY_DOWN:		// dn arrow key
            myApp.shape_ypos -= 0.025;
            cout << "dn-arrow key. \t myApp.shape_ypos = "
                 << myApp.shape_ypos << endl;
			break;
		case GLUT_KEY_UP:		// up arrow key
            myApp.shape_ypos += 0.025;
            cout << "up-arrow key. \t myApp.shape_ypos = "
                 << myApp.shape_ypos << endl;
			break;
        case GLUT_KEY_PAGE_UP:
            myApp.shape_zpos += 0.025;
            cout << "page-up key. \t myApp.shape_zpos = "
                 << myApp.shape_zpos << endl;
            break;
        case GLUT_KEY_PAGE_DOWN:
            myApp.shape_zpos -= 0.025;
            cout << "page-dn key. \t myApp.shape_zpos = "
                 << myApp.shape_zpos << endl;
            break;
		// SEARCH glut.h for more special-key #define statements.
		case GLUT_KEY_HOME:
            myApp.shape_xpos = 0.0;     // reset position
            myApp.shape_ypos = 0.0;
            myApp.shape_zpos = 0.0;
            myApp.shape_deg = 0.0;
            break;
        case GLUT_KEY_F1:
            myApp.shapeNum = (++myApp.shapeNum) % 8;   // 8 choices only.
            cout << "F1 key: change shapes: shapeNum = "
                 << myApp.shapeNum << endl;
            break;
        case GLUT_KEY_F2:
            myApp.shape_degStep -= 0.12345;
            cout << "F2 key: accelerate CW: shape_degStep = "
                 << myApp.shape_degStep << endl;
            break;
        case GLUT_KEY_F3:
            myApp.shape_degStep += 0.123456;
            cout << "F3 key: accelerate CCW: shape_degStep = "
                 << myApp.shape_degStep << endl;
            break;
		default:
			cout << "Special key; integer code value"<< (int)key << "\n)";
			break;
	}
    myApp.drawText3d(0.5, -0.7, -0.9, "!That's a SPECIAL key!", 0);
    //===============DRAWING DONE.
    glFlush();	        // do any and all pending openGL rendering.
    glutSwapBuffers();	// For double-buffering: show what we drew.
}

void myMouseClik(int buttonID, int upDown, int xw, int yw)
//-----------------------------------------------------------------------------
// (REGISTERED AS GLUT 'mouse' CALLBACK--don't call this fcn in your code!)
// Called by GLUT when users press or release a mouse button;
//                          buttonID== 0 for left mouse button,
//                                 (== 1 for middle mouse button?)
//	                                == 2 for right mouse button;
//	                        upDown  == 0 if mouse button was pressed,
//	                                == 1 if mouse button released.
//	xw,yw == mouse position in window-system pixels (origin at UPPER left!)
{
int xpos,ypos;  // mouse position in coords with origin at lower left.

    xpos = xw;
    ypos = myApp.display_height - yw;//(window system puts origin at UPPER left)
    myApp.reportKeyModifiers("myMouseClik()");//Report any SHIFT,ALT,CTRL usage
    cout << "click; buttonID=" << buttonID <<", upDown=" << upDown;
    cout << ", at xpos,ypos=(" << xpos <<"," << ypos << ")\n";
    myApp.drawText3d(0.4, 0.8, -0.9, "!MOUSE CLICK!", 4);
    //===============DRAWING DONE.
    glFlush();	        // do any and all pending openGL rendering.
    glutSwapBuffers();	// For double-buffering: show what we drew.
}

void myMouseMove(int xw, int yw)
//-----------------------------------------------------------------------------
// (REGISTERED AS GLUT 'motion' CALLBACK--don't call this fcn in your code!)
// Called by GLUT when user moves mouse while pressing any mouse button.
//	xw,yw == mouse position in window-system pixels (origin at UPPER left)
{
int xpos,ypos;  // mouse position in coords with origin at lower left.

    xpos = xw;
    ypos = myApp.display_height - yw;
    //(window system puts origin at UPPER left; myApp puts origin at LOWER right

    myApp.reportKeyModifiers("myMouseMove()"); //Report any SHIFT,ALT,CTRL usage
    cout << ".";                    // tick-mark for each sensed position change
    glColor3d(1.0, 0.5, 0.5);	//bright red text:
    myApp.drawText3d(-0.3 + 0.001*xpos,
                     -0.3 + 0.001*ypos, -0.9, "!MOUSE MOVE!", 4);

    //===============DRAWING DONE.

//    glFlush();	        // do any and all pending openGL rendering.
    glutSwapBuffers();	// For double-buffering: show what we drew.
    glutPostRedisplay();
}

void runAnim(int isOn)
//-----------------------------------------------------------------------------
// Call runAnim(0) to STOP animation;
//      runAnim(1) to START or CONTINUE it.
{
    myApp.doAnim = isOn;   // Update global var to the most-recent state;
    if(isOn == 1)          // Start or continue animation?
    {   //YES. ANIMATE!   register a GLUT timer callback:
        glutTimerFunc(myApp.animFrameTime, myTimer, 1);
        // This registers 'myTimer()' as a timer callback function.
        // GLUT will now pause NU_PAUSE milliseconds (longer if busy drawing),
        // call myTimer(1), and then 'un-register' the callback; it won't call
        // myTimer() again unless we register it again.
        // myTimer(1) checks to be SURE no other 'stop animation' requests
        // arrived (e.g. keyboard input, mouse input, visibility change, etc.)
        // while we waited.  If global variable nu_Anim_isOn is STILL 1,
        // it calls runAnimTimer(1) to continue animation.
    }
    // NO.  STOP animation-- don't register a GLUT timer for myTimer().
}

void myTimer (int value)
//------------------------------------------------------------------------------
// Don't call this function yourself; use runAnim() instead!
// runAnim(1) causes GLUT to wait NU_PAUSE milliseconds (longer if busy)
// and then call this function.
// TRICKY: We allow users to choose very long NU_PAUSE times to see what happens
// in animation.  During GLUT's wait time, user events (keyboard, mouse, or
// window cover/uncover) may make runAnim(0) calls intended to STOP
// animation.  GLUT can't cancel a previously-issued GLUT timer callback, so
// in the TimerCallback() function we check global variable nu_Anim_isON.
{
                                // GLUT finished waiting.
    if(value != myApp.doAnim)
        cout << "\n(Anim cancelled during GLUT wait)\n";
    if(myApp.doAnim==1)         // Go on with animation?
    {                           // YES.
        glFlush();              // Finish any pending drawing requests,
        glutPostRedisplay();    // tell GLUT to re-draw the screen, and
        runAnim(1);             // continue with the next time interval.
    }
                                // NO. Do nothing. No further animation.
}

void myHidden (int isVisible)
//------------------------------------------------------------------------------
// (REGISTERED AS GLUT 'visibility' CALLBACK--don't call this fcn in your code!)
// Called by GLUT when our on-screen window gets covered or un-covered. When
// called, it turns off animation and re-display when our display window is
// covered or stowed (not visible). SEE ALSO: runAnimTimer() and myTimer()
{
    if(isVisible == GLUT_VISIBLE)  runAnim(1);      // Visible! YES! Animate!
    else runAnim(0);                                // No. Stop animating.
}

CTheApp::CTheApp(void)
//------------------------------------------------------------------------------
// default constructor
{
    display_width = 640;	            // global variables that hold current
    display_height = 640;	            // display window position and size;
    display_xpos = 200;
    display_ypos = 100;
    strncpy(winTitle, "2011 NU EECS 351-1 GlutPak", 127); // (buffer size:128)
    doAnim  = 1;                      // ==1 to run animation, ==0 to pause.
    doClear = 1;
    animFrameTime = NU_PAUSE;           // default: wait between frames in mS
    // screen-clear color;
    clrColr4dv[0]= 0.7;
    clrColr4dv[1]= 0.7;
    clrColr4dv[2]= 0.7;
    clrColr4dv[3]= 0.7;
    // drawing (pen) color;
    penColr4dv[0]= 82.0/255.0;      // color; 0.0<=RGB<=1.0, GLdouble
    penColr4dv[1]= 0.0;             // Official NU purple; R== 82, G== 0, B== 99
    penColr4dv[2]= 99.0/255.0;
    penColr4dv[3]= 0.0;
    // text-writing color;
    txtColr4dv[0] = 0.1;
    txtColr4dv[1] = 0.4;
    txtColr4dv[2] = 0.1;
    txtColr4dv[3] = 0.5;
    // error-reporting color;
    errColr4dv[0] = 0.0;    // PURE BLACK
    errColr4dv[1] = 0.0;
    errColr4dv[2] = 0.0;
    errColr4dv[3] = 1.0;

    shapeNum = 0;                       // Shape-selector number.
    shape_xpos = shape_ypos = 0.0;      // initial position (arrow keys)
    shape_deg = 0.0;                    // initial orientation
    shape_degStep = 0.51;               // rotation (degrees) per time-step

    //  Start up the FreeImage library for image-file I/0:
#ifdef FREEIMAGE_LIB
	// call this ONLY when linking with FreeImage as a static library
		FreeImage_Initialise();
#endif
}

CTheApp::~CTheApp(void)
//------------------------------------------------------------------------------
// default destructor
{
	// call this ONLY when linking with FreeImage as a static library
	#ifdef FREEIMAGE_LIB
		FreeImage_DeInitialise();
	#endif
    return;
}

void CTheApp::reportKeyModifiers(const char *pName)
//------------------------------------------------------------------------------
// Text and graphical display of any keyboard modifiers (SHIFT, CTRL, ALT).
// Used by keyboard & mouse callback fcns.
// Usage:  within myKeyboard() --   myApp.reportKeyModifiers("myKeyboard()");
{
    KBflags = glutGetModifiers();           // GLUT's keyboard-mod reader
    if(KBflags & GLUT_ACTIVE_SHIFT)
    {
        drawText3d(-0.9, 0.9, -0.9, "!!!SHIFT KEY!!!", 4);  // on-screen
        cout << pName << ": SHIFT-key" << endl;             // in text window
    }
    if(KBflags & GLUT_ACTIVE_CTRL )
    {
        drawText3d(-0.9, 0.8, -0.9, "!!! CTRL KEY!!!", 4);
        cout << pName << ": CTRL-key" << endl;
    }
    if(KBflags & GLUT_ACTIVE_ALT  )
    {
        drawText3d(-0.9, 0.7, -0.9, "!!! ALT  KEY!!!", 4);
        cout << pName << ": ALT-key" << endl;
    }
}

void CTheApp::drawAxes(void)
//------------------------------------------------------------------------------
// Draw small +x,+y,+z axes in red, green, blue:
{
	glColor3d(1.0, 0.0, 0.0);	// red
	glBegin(GL_LINES);
		glVertex3d(0.0,0.0,0.0);	// +x-axis
		glVertex3d(0.4,0.0,0.0);
	glEnd();
	drawText3d(0.4, 0.0, 0.0, "X", 2);       // label it.

	glColor3d(0.0, 1.0, 0.0);	// green
	glBegin(GL_LINES);
		glVertex3d(0.0,0.0,0.0);	// +y-axis
		glVertex3d(0.0,0.4,0.0);
	glEnd();
    drawText3d(0.0, 0.4, 0.0, "Y", 2);       // label it.

	glColor3d(0.0, 0.5, 1.0);	// bright blue
	glBegin(GL_LINES);
		glVertex3d(0.0,0.0,0.0);	// +z-axis
		glVertex3d(0.0,0.0,0.4);
	glEnd();
	drawText3d(0.0, 0.0, 0.4, "Z" ,2);       // label it.
}

void CTheApp::drawText3d( GLdouble x0, GLdouble y0, GLdouble z0,
                         const char *pString, int fontNum)
//-----------------------------------------------------------------------------
//  Use GLUT to write (bitmapped) text string that starts at pointer 'pString'.
//  --Use current pen color (CTheApp::penColrv4), but if the text string begins
//      with an exclamation point, it uses error color (CTheApp::errColrv4).
//  --Places the lower left corner of the first line of text at screen position
//      x0,y0,z0 in the current coordinate system.
//      Example:  DrawText3D(0.3, 0.4, 0.0,"Hello!", 4);
//  -- uses 'fontNum' to select among these GLUT pre-defined fonts:
// Font#
//  0   --  10pt HELVETICA
//  1   --  12pt HELVETICA
//  2   --  18pt HELVETICA
//  3   --  10pt TIMES_ROMAN
//  4   --  24pt TIMES_ROMAN
//-------------------------------
// NOTE: Unlike GLUT, the freeGLUT library offers support for stroke-font chars
// and functions for strings; you may want to use that instead
// SEE: glutBitmapString(), glutStrokeCharacter(), glutStrokeString() at this
//  site:  http://freeglut.sourceforge.net/docs/api.php#Introduction
{
int i, imax;					// character counters
void *pFont;                    // function ptr for fonts

    // IF string begins with '!' (exclamation point)
    if(pString[0]=='!' || pString[1]=='!')
         glColor4dv(errColr4dv);        // use the 'error' text color
    else glColor4dv(txtColr4dv);	    // otherwise, ordinary text color
    switch(fontNum)
    {
        case 0: pFont = GLUT_BITMAP_HELVETICA_10;   break;
        case 1: pFont = GLUT_BITMAP_HELVETICA_12;   break;
        case 2: pFont = GLUT_BITMAP_HELVETICA_18;   break;
        case 3: pFont = GLUT_BITMAP_TIMES_ROMAN_10; break;
        case 4:     // (the default choice)
        default:pFont = GLUT_BITMAP_TIMES_ROMAN_24; break;
    }
	glRasterPos3d(x0, y0, z0);	// set text's lower-left corner position
	imax = 1023;				// prevent overflow.
	for(i=0; pString[i] != '\0' && i<imax; i++)	// for each char,
	{
		glutBitmapCharacter(pFont, pString[i]);
	}
}

void CTheApp::drawShape(void)
//------------------------------------------------------------------------------
// Use 'penColr[]' to draw the GLUT shape selected by 'shapeNum' at (xpos,ypos)
// using the current coordinate system.
// TRANSFORMATION SYNTAX HINTS:
//	glRotated(-123, 1,-2,1);	// rotate by -123 degrees around 3D axis vector;
//	glScaled(0.2, 0.3, 0.4);	// shrink along x,y,z axes
//  glTranslated(0.1,0.3,0.5);	// translate along x,y,z axes.
{
    glMatrixMode(GL_MODELVIEW);     // use this matrix to change coord systems
    glPushMatrix();                 // save its current value,

        glTranslated(shape_xpos, shape_ypos, shape_zpos);   // change coords.
        // Draw a selected shape from those GLUT supplies 'ready-made':
        glRotated(shape_deg, 0.0, 0.0, 1.0);       // rotate around Z axis.

        // Set drawing color:
        glColor4dv(penColr4dv);      // Set pen color,
        switch(shapeNum)            // Draw the (selected) GLUT shape
        {
            case 0: glutWireCube( 1.0 ); break; // length of cube's edges
            case 1: glutSolidCube ( 1.0 ); break;
            // How is glRectd() different?.... (HINT: it's 2D, not 3D)
            //      glRectd(-0.5, -0.5,     // Lower-left x,y
            //               0.5,  0.5);     // Upper-right x,y.
                             break;
            case 2:
                glPushMatrix();             // save current tranformation matrix
                    glRotated(80.0,0.0, 1.0, 0.0);  // turn 80 deg on y axis,
                    glutWireCone( 1.0, 1.0, 10, 6 );// draw 3D cone
                glPopMatrix();              // restore prev. transform. matrix
            break;
            case 3:
                glPushMatrix();             // save current tranformation matrix
                    glRotated(80.0,0.0, 1.0, 0.0);  // turn 80 deg on y axis,
                    glutSolidCone( 1.0, 1.0, 10, 6);// draw 3D cone
                glPopMatrix();              // restore prev. transform. matrix
            break;
            case 4:
                glPushMatrix();             // save current tranformation matrix
                    glRotated(40.0,0.0, 1.0, 0.0);  // turn 40 deg on y axis,
                    glutWireTorus(
                    0.3,            // inner radius, (smaller of the 2 radii;
                                    // radius of rings enclosing 'core-circle' )
                    0.7,            // outer radius, (larger of the 2 radii;
                                    // for 'core circle' enclosed within torus)
                    16,             // number of sides for each ring;
                    32);            // number of rings around center-circle.
                glPopMatrix();              // restore prev. transform. matrix
                break;
            case 5:
                glutSolidTorus(
                0.3,            // inner radius, (smaller of the 2 radii;
                                // radius of rings enclosing 'core-circle' )
                0.7,            // outer radius, (larger of the 2 radii;
                                // for 'core circle' enclosed within torus)
                16,             // number of sides for each ring;
                32);            // number of rings around center-circle.
                break;
/*
Other GLUT shapes for you to try... found in GLUT.h (or freeglut_std.h)
case XX:glutWireSphere( GLdouble radius, GLint slices, GLint stacks );
case XX:glutSolidSphere( GLdouble radius, GLint slices, GLint stacks );
case XX:glutWireDodecahedron( void );
case XX:glutSolidDodecahedron( void );
case XX:glutWireOctahedron( void );
case XX:glutSolidOctahedron( void );
case XX:lutWireTetrahedron( void );
case XX:glutSolidTetrahedron( void );
case XX:glutWireIcosahedron( void );
case XX:glutSolidIcosahedron( void );
*/
            case 6:
                glPushMatrix();             // save current tranformation matrix
                glRotated(11.0, 1.0, 0.0, 0.0);  // turn 80 deg on x axis,
                    glutWireTeapot( 0.5 );
                glPopMatrix();              // restore prev. transform. matrix
                    break;      // size.
            case 7:    // (default value)
            default:    glutSolidTeapot( 0.5 );         // size.
                break;
        }
    glPopMatrix();                  // restore its previous coord. system.
    return;
}

/*===============================================================================
 OpenGL Pixel-Block Operations
 =============================
OpenGL gives you exquisitely flexible tools for manipulating blocks of pixels
held in your computers memory and in its openGL graphics hardware.  However,
the default settings are not always correct for all uses on all machines; if
not, use these formatting functions first:

FORMATTING FUNCTIONS
-------------
 --glPixelStore() lets you change the settings openGL uses to pack or unpack
    blocks of pixels stored in your computer's memory (in 'client side' buffers).
    It can accomodate almost any client memory requirements; for example, it lets
    you specify that that each scanline read/write begins on 8, 16, or 32 bit
    boundaries (nice for MS Windows); it lets you specify byte-order swaps
    (nice for Apple OS-X or any little-endian vs. big-endian mismatches:
        http://en.wikipedia.org/wiki/Endianness.
  **SUMMARY: glPixelStore() lets openGL read & write pixel blocks in the
                correct format for YOUR computer's memory arrays.
  **CAREFUL! Don't assume default values for glPixelStore() are what you want!

--glPixelTransfer() lets you change openGL settings that enable it to modify or
    rearrange pixel values during pixel-block transfers between buffers.  For
    example, it could rearrange BGR-format pixels to RBG format as it transfers
    them from a client-side buffer (your computer's memory) to a texture buffer.
    It can use color index tables, gamma correction lookup tables,change stencil
    bits and more.  All specified changes apply to all transfers, including those
    by glDrawPixels(), glReadPixels(), glCopyPixels(), and glTexImage() etc.
  **SUMMARY: glPixelTransfer() changes colors, indices, maps, scales & biases.
  **NOTE: Programs using only true-color images rarely need glPixelTransfer().

--glPixelMap() lets to create the lookup tables used by glPixelTransfer(). These
    lookup tables change pixel values, such as gamma-correction tables applied
    to R,G,B,A values, or tables that set stencil values.
  **SUMMARY: 'glPixelMap() stores maps and tables used by glPixelTransfer().
  **NOTE: If you don't need glPixelTransfer(), you don't need glPixelMap().

BUFFER SELECTION FUNCTIONS
---------------------------
The openGL 'Pixel-Block' manipulating functions give us, by default, access to
the openGL color buffer(s) used for drawing on-screen.
For single-buffered display, they use the GL_FRONT buffer by default;
for double-buffered display, they use the GL_BACK  buffer by default.
To change that, call
    --glReadBuffer() to set the source buffer for pixel-block reading,
    --glDrawBuffer() to set the destination buffer for pixel-block writing.

Available Color Buffer Choices:
--In addition to GL_FRONT and GL_BACK, you may find the GL_FRONT_AND_BACK
    choice useful for some interactive, double-buffered applications. After the
    function call glDrawBuffer(GL_FRONT_AND_BACK), pixel-block functions will
    write to BOTH the front and back buffers simultaneously.
--Double-buffered stereo display implemented in openGL gives you four usable
    color buffers: GL_RIGHT_FRONT, GL_LEFT_FRONT,GL_RIGHT_BACK,GL_LEFT_BACK.
--Better graphics hardware provides 'auxiliary' color buffers (GL_AUX0,
    GL_AUX1, GL_AUX2, ... GL_AUXn) to hold partial renderings for tasks such as
    picking,shadows, transparency, and anti-aliasing.
--Texture Buffers: the long-awaited 'render-to-texture' functions that
    let you use your display image as a texture map.

PIXEL-MOVING FUNCTIONS
-----------------------
--glBitmap() unpacks a rectangle of 1-bit values from your computer's memory
    (a client-side buffer) to the openGL display. The default 'unpacking' method
    usually works on all machines if you store sequential bits in sequential
    bytes in sequential rows ('row-major' order). If not, see glPixelStore() to
    select the formatting you prefer for your computer's memory.
        glBitmap() draws the lower-left corner of the bitmap rectangle at the
    (transformed) GL_CURRENT_RASTER_POSITION vector value set by glRasterPos*().
    (Note this position gets transformed bu GL_MODELVIEW and GL_PROJECTION
    before use).  It draws the rectangles' contents on-screen (1 bit per pixel),
    and then changes the GL_CURRENT_RASTER_POSITION value by an amount you
    specify (often it's just (0,0)).
        OpenGL offers 16 different ways to 'draw' a bitmap on-screen, but the
    default 'overlay' method is very simple. Where the bitmap==0, leave pixel
    values unchanged; where the bitmap==1, replace the existing display color
    with openGL's current bitmap-drawing color (usually the glColor() value).
    SEE: http://www.opengl.org/sdk/docs/man/xhtml/glBitmap.xml
    -----Bitmap-Drawing Color:-----
        When you call 'glRasterPos*()' it saves the most recent glColor() value
    as the bitmap-drawing color; when you call glBitmap(), it uses this color
    and clears the bitmap-drawing color.  If you call you call glBitmap() while
    the bitmap-drawing color is cleared, it uses the current glColor() instead.
    -----Other Bitmap Drawing Ops-----
    To use any non-default drawing method, you must:
     a) enable it: call glEnable(GL_COLOR_LOGIC_OP);  (disabled by default)
     b) specify it: call glLogicOp() with the desired drawing method as argument.
        Besides the default GL_OVERLAY arg, try GL_COPY, GL_OR, or GL_XOR.
        See:   http://www.opengl.org/sdk/docs/man/xhtml/glLogicOp.xml

--glDrawPixels() 'unpacks' a rectangular block of pixels from your computer's
    memory (a client-side buffer) and copies them to the openGL display at the
    (transformed) CURRENT_RASTER_POSITION value set by glRasterPos().
    The default 'unpacking' method usually works on all machines if you store
    sequential pixel-components (RGB, RGBA, etc) in sequential pixels in
    sequential rows ('row-major' order), e.g. GLubyte buf[HEIGHT][WIDTH][COLOR];
    If not, see glPixelStore() to specify your machine's formatting.
    glDrawPixels() places the lower-left corner of the user's block of pixels
    on-screen at the (transformed) glRasterPos*() position (the position gets
    transformed by GL_MODELVIEW and GL_PROJECTION before use).
        SEE:   http://www.opengl.org/sdk/docs/man/xhtml/glDrawPixels.xml

--glReadPixels() selects a rectangular block of pixels from openGL's display
    buffer from absolute window position (x,y) and 'packs' them into a user-
    supplied memory buffer (a client-side buffer).  The default 'packing' method
    usually works for all machines if you read the result using sequential
    pixel-components (RGB, RGBA, etc), in sequential pixels in sequential rows
    ('row-major' order), e.g. GLubyte buf[HEIGHT][WIDTH][COLOR];
    If not, use the glPixelStore() fcn. to specify your machine's formatting.
    CAREFUL!  glReadPixels() does NOT use glRasterPos() position (screen position

--glCopyPixels() copies a rectangular block of pixels at the absolute window
    position (x,y) and writes them to the (transformed) glRasterPos() position
    in the same openGL buffer.  It needs no client-side memory buffer, and thus
    is much, much faster than calling glReadPixels() and then glDrawPixels().
*/

void CTheApp::printPixelStoreTest(void)
//------------------------------------------------------------------------------
// OpenGL gives you exquisitely flexible tools for manipulating blocks of pixels
// in any arrangement in memory on any machine, but it's default settings aren't
// always correct for all uses on all machines.  This function reports the
// current settings openGL will use to pack or unpack blocks of pixels you store
// in your computer's memory ( in 'client side' buffers, not in the GPU).
// To modify these settings, call glPixelStore(), explained here:
//          http://www.opengl.org/sdk/docs/man/xhtml/glPixelStore.xml
{
GLboolean isTrueA, isTrueB;
GLint  countA, countB;

    cout << "===================printPixelStoreTest()==================" <<endl;
    glGetBooleanv(  GL_PACK_SWAP_BYTES, &isTrueA);
    glGetBooleanv(GL_UNPACK_SWAP_BYTES, &isTrueB);
    cout << "      GL_PACK_SWAP_BYTES\t";
    if(isTrueA == TRUE) cout << "TRUE\t";
                else    cout << " no \t";
    cout << "    GL_UNPACK_SWAP_BYTES\t";
    if(isTrueB == TRUE) cout << "TRUE" << endl;
                else    cout << " no  " << endl;
    //------------
    glGetBooleanv(  GL_PACK_LSB_FIRST, &isTrueA);
    glGetBooleanv(GL_UNPACK_LSB_FIRST, &isTrueB);
    cout << "      GL_PACK_LSB_FIRST  \t";
    if(isTrueA == TRUE) cout << "TRUE \t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_LSB_FIRST  \t";
    if(isTrueB == TRUE) cout << "TRUE" << endl;
                else    cout << " no  " << endl;
    //------------
    glGetIntegerv(  GL_PACK_ROW_LENGTH, &countA);
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &countB);
    cout << "      GL_PACK_ROW_LENGTH \t";
    if(countA != 0) cout << countA <<"\t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_ROW_LENGTH\t";
    if(countB != 0) cout << countB << endl;
                else    cout << " no  " << endl;
    //------------
    // THIS NEXT VALUE ISN'T AVAILABLE.
/*    glGetIntegerv(  GL_PACK_IMAGE_HEIGHT, &countA);
    glGetIntegerv(GL_UNPACK_IMAGE_HEIGHT, &countB);
    cout << "      GL_PACK_IMAGE_HEIGHT\t";
    if(countA != 0) cout << countA << "\t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_IMAGE_HEIGHT\t";
    if(countB != 0) cout << countB << endl;
                else    cout << " no  " << endl;
*/   //------------
    glGetIntegerv(  GL_PACK_SKIP_PIXELS, &countA);
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &countB);
    cout << "      GL_PACK_SKIP_PIXELS \t";
    if(countA != 0) cout << countA << "\t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_SKIP_PIXELS\t";
    if(countB != 0) cout << countB << endl;
                else    cout << " no  " << endl;
    //------------
    glGetIntegerv(  GL_PACK_SKIP_ROWS, &countA);
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &countB);
    cout << "      GL_PACK_SKIP_ROWS  \t";
    if(countA != 0) cout << countA << "\t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_SKIP_ROWS  \t";
    if(countB != 0) cout << countB << endl;
                else    cout << " no  " << endl;
    //------------
/*    glGetIntegerv(  GL_PACK_SKIP_IMAGES, &countA);
    cout << "      GL_PACK_SKIP_IMAGES\t";
    if(countA != 0) cout << countA << endl;
                else    cout << " no " << endl;;
*/    //------------
    glGetIntegerv(  GL_PACK_ALIGNMENT, &countA);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &countB);
    cout << "      GL_PACK_ALIGNMENT  \t";
    if(countA != 0) cout << countA << "\t";
                else    cout << " no  \t";
    cout << "    GL_UNPACK_ALIGNMENT   \t";
    if(countB != 0) cout << countB << endl;
                else    cout << " no  " << endl;
}

void CTheApp::drawBitmapTest(void)
//------------------------------------------------------------------------------
// (called within the myDisplay() callback).  Demo for openGL's bitmap-drawing:
// build a 1-bit checkerboard 96wide x 64tall and 'overlay' it on-screen with
// its lower-left corner at (0.5, -0.5) (set by openGL's raster position) in the
// current coordinate system. CAREFUL! this starting position gets transformed
// by GL_MODELVIEW, GL_PROJECTION!  By default, bitmap drawing leaves the screen
// unchanged where bitmap==0, and changes screen color 'current raster color'
// (which we set to orange) where bitmap==1.
//
// NOTE!  If you want to describe your bitmap positions in on-screen pixels, you
// can set GL_MODELVIEW to the identity matrix, set GL_PROJECTION using
// gluOrtho2D(0,width,0,height), and then the 'current coordinate system' will
// put origin at window's lower-left corner, will measure x,y increasing upwards
// and rightwards, in pixel units.  (See Ed Angel, "OpenGL, A Primer" pg 163,4)
{
GLubyte blackWhite[2] = {0x00, 0xff};
#define JT_BIT_WIDE 96
#define JT_BIT_HIGH 64
                            // 8-bit row of black bits, or of white bits
GLubyte checkerbd[JT_BIT_WIDE * JT_BIT_HIGH / 8];
                            // a 96x64 single-bit array (6144 bits/8=768 bytes)
                            // NOTE! my Windows machine requires each scanline
                            // to end on 32-bit boundaries in memory;
                            // widths not divisible by 32 require extra space

int i,j;                    // x,y counters

    // VERY BAD IDEA!! We're initializing the bitmap array every time we draw it
    // Better idea; make the bitmap (the checkerbd[] array) a member of the
    // CTheApp class, and initialize it once and only once:
    for(j=0; j<JT_BIT_HIGH; j++)     // for each row of bits
    {
        for(i=0; i<(JT_BIT_WIDE/8); i++) // for each byte on the row(96/8 = 12)
        {
            checkerbd[i + j*(JT_BIT_WIDE/8)] = blackWhite[(i + j/8)%2];
                                                // reverse after
                                                // every 8 columns (1 byte) and
                                                // every 8 columns (j/8)
        }
    }
    glColor3d(0.8, 0.4, 0.1); // set openGL's drawing color to strong orange.

    // CAREFUL! current glColor gets 'locked in' as the bitmap color when we
    // call glRasterPos().  You can't change the bitmap color again until after
    //  you draw the bitmask with that color. (pg 161,2)

    // Set raster position (GL_CURRENT_RASTER_POSITION)for bitmap/image drawing:
    glRasterPos2d(0.5, -0.5);
    // NOTE: 'overlay' drawing (default) is just one of 16 logical operators
    // available for bitmap-drawing. To try other logical ops, use the
    // glEnable(GL_COLOR_LOGIC_OP) and glLogicOp() functions.

    // Call 'glBitmap()' to draw the bitmap in that color at that location:
    glBitmap(JT_BIT_WIDE, JT_BIT_HIGH,      // bitmap width, height
             0.0, 0.0,                      // bitmap xorig, yorig
             0.0, 0.0,                      // bitmap xmove, ymove
             checkerbd);            // pointer-to-1st-GLubyte of stored bitmap

#undef JT_BIT_WIDE
#undef JT_BIT_HIGH
}

void CTheApp::drawPixBlockTest(void)
//------------------------------------------------------------------------------
// (called within the myDisplay() callback).  Test/demo for the glDrawPixels()
// fcn that copies a block of pixels from memory to screen at the 'glRasterPos'
// position.   (See Ed Angel, "OpenGL, A Primer" pg 165-177)
// Create a test-pattern in memory, then transfer pixels from memory to screen.
{
#define JT_TEST_WIDTH   128             // Windows scanlines; multiples of 32.
#define JT_TEST_HEIGHT   92

GLubyte img[JT_TEST_HEIGHT][JT_TEST_WIDTH][3];
int i,j;                               // x,y,color array for a test image.


    // VERY BAD IDEA!! We're initializing this array every time we draw it.
    // Better idea; make the image (the img array) resizeable (dyn. alloc'd)
    // and a member of the CTheApp class.  Initialize it once and only once.
    for(j=0; j<JT_TEST_HEIGHT; j++)     // for each image row,
    {
        for(i=0; i<JT_TEST_WIDTH; i++)  // for each pixel on that row,
        {           // make a pretty test pattern: color values within 0-255:
            img[j][i][0] = (((43 +i -2*j)%53)*255)/53;      // red
            img[j][i][1] = (((    i +  j)%31)*255)/31;      // grn
            img[j][i][2] = (((17      -j)%41)*255)/41;      // blu
        }
    }
    // Set OpenGL's 'raster position';
    glMatrixMode(GL_MODELVIEW);        // save current modelview matrix,
    glPushMatrix();
        glLoadIdentity();                   // set to identity;
        glMatrixMode(GL_PROJECTION);     // save current projection matrix,
        glPushMatrix();
            glLoadIdentity();               // set to identity;
            glRasterPos3d(0.5, 0.5, 0.0);// set 3D position for any raster-ops
                                        // in the current coordinate system.
                                        // (CAREFUL! this position gets xformed
                                        // by GL_MODELVIEW and GL_PROJECTION
                                        // before use!
    // Draw pixel block, with lower-left corner at openGL's 'raster position'.
            glDrawPixels(JT_TEST_WIDTH, JT_TEST_HEIGHT,
                                        // image width, height in pixels
//    glDrawPixels(JT_TEST_HEIGHT, JT_TEST_WIDTH,// image width, height in pixels
                 GL_RGB,                // Pixel size (GL_RGB or GL_RGBA)
                 GL_UNSIGNED_BYTE,      // data type for each pixel component,
                 img);                  // pointer-to-image starting point.
        glPopMatrix();                  // restore previous projection matrix,
        glMatrixMode(GL_MODELVIEW);
    glPopMatrix();                      // restore previous modelview matrix,
}

void CTheApp::readPixBlockTest(void)
//------------------------------------------------------------------------------
// (called within the myDisplay() callback).  Test/demo for the glReadPixels()
// fcn that copies a block of pixels from screen to memory.
// (See Ed Angel, "OpenGL, A Primer" pg 165-177)
//
// THIS FUNCTION REQUIRES that you call 'drawPixBlockTest()' first,
//  because it reads the same portion of screen memory, compares each pixel
// value read against its re-computed value, and then re-draws what it read
// in a new position on-screen.
//
// When this function works, it displays a duplicate test pattern at(-0.5,0.5),
// that it copied from the pattern shown onscreen at (0.5,0.5) drawn by the
// drawPixBlockTest().
// To PROVE that it's reading screen pixels and testing their values against
// the computed test pattern, just re-size the display.  This briefly devastates
// the program: the first re-sized call to drawPixBlockTest() draws the test
// pattern at a new place, and readPixBlockTest() doesn't find it with its
// outdated xwin,ywin positions.  It fills the console with error reports for
// each mismatched pixel (but stops after the first 50).  This continues for
// each newly-resized display re-draw, until finally readPixBlockTest() catches
// up, and its xwin,ywin once again matches the correct position for the test
// pattern drawn by drawPixBlockTest().
// As a further test, reduce the display-window width enough to hide part of the
// test-pattern drawn on the right by drawPixBlockTest().  This should give you
// an unending stream of error reports from readPixBlockTest(), and corrupt the
// right side of the test-pattern it draws on the left of the display screen.
// As it cannot read pixels outside the window, its right-most pixels never get
// updated, and thus do not match the computed test-pattern values.
{
GLubyte img[JT_TEST_HEIGHT][JT_TEST_WIDTH][3]; // buffer for copied pixels.
int i,j,k;
double xr,yr;               // GL_CURRENT_RASTER_POSITION in current
                            // coord. system (the CVV: +/-1 spans display window
GLint xwin,ywin;            // GL_CURRENT_RASTER_POSITION in pixels

    // READ the screen pixels used in drawPixBlockTest() fcn above:
    // TRICKY because glReadPixels() uses absolute window coords, and not
    // the glRasterPos() value ( e.g. transformed GL_CURRENT_RASTER_POSITION)
    //
    // SOLUTION; in glDrawPixBlockTest() function above, we MADE SURE to:
    // 1) draw the blow of pixels at glRasterPos position (0.5, 0.5).
    // 2) draw the block of pixels with only the identity transformations;
    // 3) use glViewport() command (in the myReshape() callback fcn above)
    //   that fills the entire display window with the CVV (+/-1 in x,y,z)
    // 4) the CTheApp object 'myApp' holds display window size as:
    //              (myApp.display_width, myApp.display_height).
    // THUS to convert from 'glRasterPos' coordinates (xr,yr) in CVV units to
    // the absolute display window coordinates (xpix,ypix) in pixels with
    // origin at lower left; Note that (xr+1.0) spans 0.0 -- 2.0, then write:

    xr = 0.5; yr =0.5;          // raster position used in drawPixBlockTest().
    xwin =  myApp.display_width * ((xr + 1.0)/2.0);// convert to window pixels
    ywin =  myApp.display_height* ((yr + 1.0)/2.0);

    // copy rectangle of pixels from screen;
    glReadPixels(xwin,ywin,     // lower-left corner pixel, in window coords
                 JT_TEST_WIDTH, JT_TEST_HEIGHT,     // how many pixels to read
                 GL_RGB,            // pixel format of openGL buffer we'll read
                 GL_UNSIGNED_BYTE,  // data type for each pixel component in
                                    // our destination buffer,
                 img);              // ptr to start address of our dest. buffer.

// OK! we read the on-screen pixels into our buffer;
// does our readout match the test pattern's computed values?
    k=0;                               // keep an error counter.
    for(j=0; j<JT_TEST_HEIGHT; j++)     // For each image row,
    {
        for(i=0; i<JT_TEST_WIDTH; i++)  // for each pixel on that row,
        {           // does the screen value match the computed value?
            if( img[j][i][0] != (GLubyte)((((43 +i -2*j)%53)*255)/53) || // red
                img[j][i][1] != (GLubyte)((((    i +  j)%31)*255)/31) || // grn
                img[j][i][2] != (GLubyte)((((17      -j)%41)*255)/41)  ) // blu
            {
                k++;                   // Count this error
                cout << "ERR! img[" << j << "][" << i << "] RGB:\t" \
                << (int)((GLubyte)(img[j][i][0])) << ", \t"  \
                << (int)((GLubyte)(img[j][i][1])) << ", \t"  \
                << (int)((GLubyte)(img[j][i][2])) << endl;
                cout << "\t Should be: \t" \
                << (int)((GLubyte)((((43 +i -2*j)%53)*255)/53)) << ", \t" \
                << (int)((GLubyte)((((    i +  j)%31)*255)/31)) << ", \t" \
                << (int)((GLubyte)((((17      -j)%41)*255)/41)) << "\n" << endl;
            }
            if(k > 10)     // have we complained too many times?
            {               // YES! stop whining; set i,j to stop the test.
                i = JT_TEST_WIDTH;
                j = JT_TEST_HEIGHT;
                cout << "--------------------------------------------"<< endl;

            }
        }
    }
    // Set OpenGL's 'raster position';
    glRasterPos3d(-0.5, 0.5, 0.0);       // set 3D position for any raster-ops
                                        // in the current coordinate system.
                                        // (CAREFUL! this position gets xformed
                                        // by GL_MODELVIEW and GL_PROJECTION
                                        // before use!
    // Draw pixel block, with lower-left corner at openGL's 'raster position.
    glDrawPixels(JT_TEST_WIDTH, JT_TEST_HEIGHT,// image width, height in pixels
//    glDrawPixels(JT_TEST_HEIGHT, JT_TEST_WIDTH,// image width, height in pixels
                 GL_RGB,                // Pixel size (GL_RGB or GL_RGBA)
                 GL_UNSIGNED_BYTE,      // data type for each pixel component,
                 img);                  // pointer-to-image starting point.

#undef JT_TEST_WIDTH
#undef JT_TEST_HEIGHT
}

void CTheApp::copyPixBlockTest(void)
//------------------------------------------------------------------------------
// Use glReadPixels() to copy a rectangular block of on-screen pixels to a
// different location on-screen.
// (See Ed Angel, "OpenGL, A Primer" pg 167-69)
{
        // YOU WRITE THIS ONE!
}

void CTheApp::readImgFile(string fname)
//------------------------------------------------------------------------------
// Read in the named image file from the current working directory (CWD);
// Currently supported file types: BMP, PPM (P3 and P6).
{
/*
fstream inFile ;            // a C++ file-buffer object
string nameBuf;             // a C++ string-buffer to hold pathName + fileName;
string lineBuf;             // a C++ string-buffer for 1 line of file's text;

string srcCode;

    fileName = fName;      // remember our path-free filename
    nameBuf = pathName + fileName;      // absolute file name (req'd for Apple)
	inFile.open (nameBuf.c_str(), ifstream::in);    // OPEN THE FILE
	if(! inFile)
	{                          // can't open file? Complain
		cout << "\n\n!!------Could not open image file: --------\n \t\t";
		cout << fName;
		cout << "\n  Full path: " << nameBuf << endl;
		cout <<   "\n--------------------------------------------\n Bye." << endl;
		exit(EXIT_FAILURE);
	}
    // READ THE FILE
    // discard any existing source code, and
	while (inFile.eof() != true)
	{
		getline(inFile, lineBuf);   // read one line from file into lineBuf
		srcCode += lineBuf;	        // append the line to our source code;
	}
	inFile.close(); // close the stream.
*/
}

//===================
//===================
//
//  CFloatImg Members
//
//===================
//===================

CFloatImg::CFloatImg(void)
//------------------------------------------------------------------------------
// Default constructor.
{
    xSize = 0;
    ySize = 0;
    pixSize = 0;
    pImg = NULL;
}

CFloatImg::~CFloatImg(void)
//------------------------------------------------------------------------------
// Default destructor
{
    sizer(0,0,0);       // discard current contents, if any
}

int CFloatImg::sizer(int xmax, int ymax, int colormax)
//------------------------------------------------------------------------------
// discard current contents and create a buffer that holds xmax,ymax pixels with
// an array of colorMax values stored ateach pixel. Returns 1 on error; else 0.
// To de-allocate all memory, call sizer(0,0,0).
{
GLfloat *pTmp = NULL;       // pointer to newly-allocated image buffer.
long int sizTot;

    if(xmax==0 || ymax==0 || colormax==0)
    {                       // if user asked for a zero-sized image, AND
        if(pImg != NULL)    // we currently hold a non-zero-sized image,
        {
            delete [] pImg; // DISCARD the existing buffer,
            pImg = NULL;    // point safely to the 'empty pointer' location
        }
        xSize = ySize = pixSize = 0;    // clear previously-held values
        return 0;
    }
    // Otherwise, try to make a new image buffer of the right size:
    sizTot = xmax * ymax * colormax;        // how many GL floats needed?
    pTmp = new (nothrow) GLfloat [sizTot];  // allocate it (NULL on error)
    if(pTmp==NULL)
    {
        cout << "\n ?!CFloatImg::sizer() can't allocate more memory!?!?\n"<< endl;
        return 1;           // STOP! Complain, but keep our old bitmap, if any.
    }
    else
    {                       // discard any existing buffer previously allocated
        delete [] pImg;
        pImg = pTmp;        // and point to the new one we just created.
        xSize = xmax;
        ySize = ymax;
        pixSize = colormax;
    }
    return 0;           // no error.
}
int CFloatImg::makeChecker(int blockSize)
//------------------------------------------------------------------------------
// Make a black-and-white checkerboard in the memory already allocated at pImg,
//using uniform blocks of (blockSize x blockSize).
// Returns 1 on error (no memory avail. at pImg) else return 0.
{
int i,j;        // pixel coords at lower-left corner of each checkerboard block
int ib,jb,oddEven;  // checkerboard block coordinates;
int s,t;            // pixel coordinates WITHIN each checkerboard block.
int k;              // color component within a pixel
long int addr;      // image array address

    if(blockSize < 0) blockSize = -blockSize;
    if(blockSize == 0 || xSize*ySize*pixSize == 0)
    {
        return 1;
        cout << "\n!?!? CFloatImg::makeChecker() zero size!?!?\n" << endl;
    }
    // Count each block in the checkerboard using (ib,jb) coordinates; (0,0) for
    // the left-most, lowermost block, increasing rightwards & upwards.
    // Find pixel position (i,j) at the corner of each checkerboard block,
    // then fill in that block with black or white.
    for(j=0, jb=0; j<ySize; j+= blockSize, jb++)    // for every row of blocks,
    {
        for(i=0, ib=0; i<xSize; i+= blockSize) // and every block on that row,
        {
            oddEven = (ib + jb)%2;   // find alternating 0,1 values for blocks.
            // use (s,t) to scan thru all pixels in the block that can fit
            // inside the bitmap.
            for(t=0; t<blockSize && (t+j)<ySize; t++)
            {   // for all rows of this block (stay within image: t+j<ysize)
                for(s=0; s<blockSize && (s+i)<xSize; s++)
                {   // and all pixels within this row of this block
                    // (stay the limits of the image: s+i < xsize)
                    addr = pixAddr(s+i, j+t);   // find this pixel's address
                    for(k=0; k<pixSize; k++)    // Write the color
                    {
                        pImg[addr+k] = (GLfloat)oddEven;    // 0.0 or 1.0.
                    }
                }
            }
        }
    }
    return 0;
}

int CFloatImg::makeRandom(int blockSize)
//------------------------------------------------------------------------------
// Make randomly-colored squares to fill the image(blockSize x blockSize) in
// the memory already allocated at pImg. Return 1 on error; else 0.
{
int i,j;        // pixel coords at lower-left corner of each checkerboard block
int ib,jb;          // checkerboard block coordinates;
int s,t;            // pixel coordinates WITHIN each checkerboard block.
int k;              // color component within a pixel
long int addr;      // image array address
GLfloat colr[4];    // randomly-chosen color (RGBA)

    if(blockSize < 0) blockSize = -blockSize;  // OOPS! fix this negative size!
    if(blockSize == 0 || xSize*ySize*pixSize <= 0 || pixSize >4)
    {
        return 1;
        cout << "\n!?!? CFloatImg::makeRandom() size wierdness!?!?\n" << endl;
    }
    // Count each colored block using (ib,jb) coordinates; (0,0) for
    // the left-most, lowermost block, increasing rightwards & upwards.
    // Find pixel position (i,j) at lower-left corner of each color block,
    // then use (s,t) coords to fill in that block with a random color.
    for(j=0, jb=0; j<ySize; j+= blockSize, jb++)    // for every row of blocks,
    {
        for(i=0, ib=0; i<xSize; i+= blockSize) // and every block on that row,
        {
            for(k=0; k<pixSize; k++)    // Choose a random color for this block
            {
                colr[k] = (GLfloat)rand()/RAND_MAX;// between 0.0 or 1.0.
            }
            for(t=0; t<blockSize && (t+j)<ySize; t++)
            {   // for all rows of this block (stay within image: t+j<ysize)
                for(s=0; s<blockSize && (s+i)<xSize; s++)
                {   // and all pixels within this row of this block
                    // (stay the limits of the image: s+i < xsize)
                    addr = pixAddr(s+i, j+t);   // find this pixel's address
                    for(k=0; k<pixSize; k++)    // Write the color
                    {
                        pImg[addr+k] = colr[k];    // block's random color.
                    }
                }
            }
        }
    }
    return 0;
}
int CFloatImg::readFilePPM(char *pName)
//------------------------------------------------------------------------------
// Discard current contents, and replace it with the image held in the named
// PPM-format file. Error? keep current contents, return 1; else 0.
{
/*
FILE *fd;
char c;         // single-char buffer for file reading
char b[1024];   // filename buffer
char bb[1024];  // line-buffer for file reading
GLUint n,m,k;   // rows, columns, colorCount

    printf("\n enter file name:");
    scanf(""%s, b);
    fd = fopen(b, "r"); // open named file for reading
    if(fd == NULL)
    {
        printf("\n!?!?Could not open file!?!? Bye.");
        return 1;
    }
    if(b[0] != 'P' || b[1] != '3')
    {
        printf("\n %s is not a PPM file!\n", b);
        return 1;
    }
    fscanf(fd, "%c", &c);
    while(c == '#')         // read, print all PPM header comments, if any
    {
        fscanf(fd, "%s[^\n]", bb);   // read entire line of comments into buffer
        printf(" COMMENT: %s\n",bb); // print comment on-screen
    }
    ungetc(c,fd);
    fscanf(fd,"%d %d %d", &n, &m, &k);
*/
    cout << "Filename:" << pName << endl;
    return 0;
}
int CFloatImg::writeFilePPM(char *pName)
//------------------------------------------------------------------------------
// Write image at 'pImg' to the file named at 'pName' using PPM format.
// WARNING! writeFilePNG() over-writes the contents (if any) of 'pName' file!
// Returns 1 on file-write error; else returns 0.
{
    return 0;
}
